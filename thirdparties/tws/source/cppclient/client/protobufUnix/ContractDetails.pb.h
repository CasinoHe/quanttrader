// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ContractDetails.proto
// Protobuf C++ Version: 5.29.1

#ifndef ContractDetails_2eproto_2epb_2eh
#define ContractDetails_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "IneligibilityReason.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ContractDetails_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ContractDetails_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ContractDetails_2eproto;
namespace protobuf {
class ContractDetails;
struct ContractDetailsDefaultTypeInternal;
extern ContractDetailsDefaultTypeInternal _ContractDetails_default_instance_;
class ContractDetails_SecIdListEntry_DoNotUse;
struct ContractDetails_SecIdListEntry_DoNotUseDefaultTypeInternal;
extern ContractDetails_SecIdListEntry_DoNotUseDefaultTypeInternal _ContractDetails_SecIdListEntry_DoNotUse_default_instance_;
}  // namespace protobuf
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace protobuf {

// ===================================================================


// -------------------------------------------------------------------

class ContractDetails_SecIdListEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractDetails_SecIdListEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractDetails_SecIdListEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractDetails_SecIdListEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractDetails_SecIdListEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractDetails_SecIdListEntry_DoNotUse*>(
        &_ContractDetails_SecIdListEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ContractDetails_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractDetails final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:protobuf.ContractDetails) */ {
 public:
  inline ContractDetails() : ContractDetails(nullptr) {}
  ~ContractDetails() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractDetails* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractDetails));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractDetails(const ContractDetails& from) : ContractDetails(nullptr, from) {}
  inline ContractDetails(ContractDetails&& from) noexcept
      : ContractDetails(nullptr, std::move(from)) {}
  inline ContractDetails& operator=(const ContractDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractDetails& operator=(ContractDetails&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractDetails* internal_default_instance() {
    return reinterpret_cast<const ContractDetails*>(
        &_ContractDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ContractDetails& a, ContractDetails& b) { a.Swap(&b); }
  inline void Swap(ContractDetails* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractDetails* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractDetails& from) { ContractDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractDetails* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "protobuf.ContractDetails"; }

 protected:
  explicit ContractDetails(::google::protobuf::Arena* arena);
  ContractDetails(::google::protobuf::Arena* arena, const ContractDetails& from);
  ContractDetails(::google::protobuf::Arena* arena, ContractDetails&& from) noexcept
      : ContractDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSecIdListFieldNumber = 17,
    kIneligibilityReasonListFieldNumber = 58,
    kMarketNameFieldNumber = 1,
    kMinTickFieldNumber = 2,
    kOrderTypesFieldNumber = 3,
    kValidExchangesFieldNumber = 4,
    kLongNameFieldNumber = 7,
    kContractMonthFieldNumber = 8,
    kIndustryFieldNumber = 9,
    kCategoryFieldNumber = 10,
    kSubcategoryFieldNumber = 11,
    kTimeZoneIdFieldNumber = 12,
    kTradingHoursFieldNumber = 13,
    kLiquidHoursFieldNumber = 14,
    kEvRuleFieldNumber = 15,
    kUnderSymbolFieldNumber = 19,
    kUnderSecTypeFieldNumber = 20,
    kMarketRuleIdsFieldNumber = 21,
    kRealExpirationDateFieldNumber = 22,
    kStockTypeFieldNumber = 23,
    kMinSizeFieldNumber = 24,
    kSizeIncrementFieldNumber = 25,
    kSuggestedSizeIncrementFieldNumber = 26,
    kFundNameFieldNumber = 27,
    kFundFamilyFieldNumber = 28,
    kFundTypeFieldNumber = 29,
    kFundFrontLoadFieldNumber = 30,
    kFundBackLoadFieldNumber = 31,
    kFundBackLoadTimeIntervalFieldNumber = 32,
    kFundManagementFeeFieldNumber = 33,
    kFundNotifyAmountFieldNumber = 37,
    kFundMinimumInitialPurchaseFieldNumber = 38,
    kFundMinimumSubsequentPurchaseFieldNumber = 39,
    kFundBlueSkyStatesFieldNumber = 40,
    kFundBlueSkyTerritoriesFieldNumber = 41,
    kFundDistributionPolicyIndicatorFieldNumber = 42,
    kFundAssetTypeFieldNumber = 43,
    kCusipFieldNumber = 44,
    kIssueDateFieldNumber = 45,
    kRatingsFieldNumber = 46,
    kBondTypeFieldNumber = 47,
    kCouponTypeFieldNumber = 49,
    kDescAppendFieldNumber = 53,
    kNextOptionDateFieldNumber = 54,
    kNextOptionTypeFieldNumber = 55,
    kBondNotesFieldNumber = 57,
    kPriceMagnifierFieldNumber = 5,
    kUnderConIdFieldNumber = 6,
    kEvMultiplierFieldNumber = 16,
    kAggGroupFieldNumber = 18,
    kFundClosedFieldNumber = 34,
    kFundClosedForNewInvestorsFieldNumber = 35,
    kFundClosedForNewMoneyFieldNumber = 36,
    kConvertibleFieldNumber = 50,
    kCouponFieldNumber = 48,
    kCallableFieldNumber = 51,
    kPuttableFieldNumber = 52,
    kNextOptionPartialFieldNumber = 56,
  };
  // map<string, string> secIdList = 17;
  int secidlist_size() const;
  private:
  int _internal_secidlist_size() const;

  public:
  void clear_secidlist() ;
  const ::google::protobuf::Map<std::string, std::string>& secidlist() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secidlist();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secidlist() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secidlist();

  public:
  // repeated .protobuf.IneligibilityReason ineligibilityReasonList = 58;
  int ineligibilityreasonlist_size() const;
  private:
  int _internal_ineligibilityreasonlist_size() const;

  public:
  void clear_ineligibilityreasonlist() ;
  ::protobuf::IneligibilityReason* mutable_ineligibilityreasonlist(int index);
  ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>* mutable_ineligibilityreasonlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>& _internal_ineligibilityreasonlist() const;
  ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>* _internal_mutable_ineligibilityreasonlist();
  public:
  const ::protobuf::IneligibilityReason& ineligibilityreasonlist(int index) const;
  ::protobuf::IneligibilityReason* add_ineligibilityreasonlist();
  const ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>& ineligibilityreasonlist() const;
  // optional string marketName = 1;
  bool has_marketname() const;
  void clear_marketname() ;
  const std::string& marketname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_marketname(Arg_&& arg, Args_... args);
  std::string* mutable_marketname();
  PROTOBUF_NODISCARD std::string* release_marketname();
  void set_allocated_marketname(std::string* value);

  private:
  const std::string& _internal_marketname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketname(
      const std::string& value);
  std::string* _internal_mutable_marketname();

  public:
  // optional string minTick = 2;
  bool has_mintick() const;
  void clear_mintick() ;
  const std::string& mintick() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mintick(Arg_&& arg, Args_... args);
  std::string* mutable_mintick();
  PROTOBUF_NODISCARD std::string* release_mintick();
  void set_allocated_mintick(std::string* value);

  private:
  const std::string& _internal_mintick() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mintick(
      const std::string& value);
  std::string* _internal_mutable_mintick();

  public:
  // optional string orderTypes = 3;
  bool has_ordertypes() const;
  void clear_ordertypes() ;
  const std::string& ordertypes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ordertypes(Arg_&& arg, Args_... args);
  std::string* mutable_ordertypes();
  PROTOBUF_NODISCARD std::string* release_ordertypes();
  void set_allocated_ordertypes(std::string* value);

  private:
  const std::string& _internal_ordertypes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordertypes(
      const std::string& value);
  std::string* _internal_mutable_ordertypes();

  public:
  // optional string validExchanges = 4;
  bool has_validexchanges() const;
  void clear_validexchanges() ;
  const std::string& validexchanges() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validexchanges(Arg_&& arg, Args_... args);
  std::string* mutable_validexchanges();
  PROTOBUF_NODISCARD std::string* release_validexchanges();
  void set_allocated_validexchanges(std::string* value);

  private:
  const std::string& _internal_validexchanges() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validexchanges(
      const std::string& value);
  std::string* _internal_mutable_validexchanges();

  public:
  // optional string longName = 7;
  bool has_longname() const;
  void clear_longname() ;
  const std::string& longname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_longname(Arg_&& arg, Args_... args);
  std::string* mutable_longname();
  PROTOBUF_NODISCARD std::string* release_longname();
  void set_allocated_longname(std::string* value);

  private:
  const std::string& _internal_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_longname(
      const std::string& value);
  std::string* _internal_mutable_longname();

  public:
  // optional string contractMonth = 8;
  bool has_contractmonth() const;
  void clear_contractmonth() ;
  const std::string& contractmonth() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contractmonth(Arg_&& arg, Args_... args);
  std::string* mutable_contractmonth();
  PROTOBUF_NODISCARD std::string* release_contractmonth();
  void set_allocated_contractmonth(std::string* value);

  private:
  const std::string& _internal_contractmonth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractmonth(
      const std::string& value);
  std::string* _internal_mutable_contractmonth();

  public:
  // optional string industry = 9;
  bool has_industry() const;
  void clear_industry() ;
  const std::string& industry() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_industry(Arg_&& arg, Args_... args);
  std::string* mutable_industry();
  PROTOBUF_NODISCARD std::string* release_industry();
  void set_allocated_industry(std::string* value);

  private:
  const std::string& _internal_industry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_industry(
      const std::string& value);
  std::string* _internal_mutable_industry();

  public:
  // optional string category = 10;
  bool has_category() const;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // optional string subcategory = 11;
  bool has_subcategory() const;
  void clear_subcategory() ;
  const std::string& subcategory() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subcategory(Arg_&& arg, Args_... args);
  std::string* mutable_subcategory();
  PROTOBUF_NODISCARD std::string* release_subcategory();
  void set_allocated_subcategory(std::string* value);

  private:
  const std::string& _internal_subcategory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subcategory(
      const std::string& value);
  std::string* _internal_mutable_subcategory();

  public:
  // optional string timeZoneId = 12;
  bool has_timezoneid() const;
  void clear_timezoneid() ;
  const std::string& timezoneid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timezoneid(Arg_&& arg, Args_... args);
  std::string* mutable_timezoneid();
  PROTOBUF_NODISCARD std::string* release_timezoneid();
  void set_allocated_timezoneid(std::string* value);

  private:
  const std::string& _internal_timezoneid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezoneid(
      const std::string& value);
  std::string* _internal_mutable_timezoneid();

  public:
  // optional string tradingHours = 13;
  bool has_tradinghours() const;
  void clear_tradinghours() ;
  const std::string& tradinghours() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tradinghours(Arg_&& arg, Args_... args);
  std::string* mutable_tradinghours();
  PROTOBUF_NODISCARD std::string* release_tradinghours();
  void set_allocated_tradinghours(std::string* value);

  private:
  const std::string& _internal_tradinghours() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tradinghours(
      const std::string& value);
  std::string* _internal_mutable_tradinghours();

  public:
  // optional string liquidHours = 14;
  bool has_liquidhours() const;
  void clear_liquidhours() ;
  const std::string& liquidhours() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_liquidhours(Arg_&& arg, Args_... args);
  std::string* mutable_liquidhours();
  PROTOBUF_NODISCARD std::string* release_liquidhours();
  void set_allocated_liquidhours(std::string* value);

  private:
  const std::string& _internal_liquidhours() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liquidhours(
      const std::string& value);
  std::string* _internal_mutable_liquidhours();

  public:
  // optional string evRule = 15;
  bool has_evrule() const;
  void clear_evrule() ;
  const std::string& evrule() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_evrule(Arg_&& arg, Args_... args);
  std::string* mutable_evrule();
  PROTOBUF_NODISCARD std::string* release_evrule();
  void set_allocated_evrule(std::string* value);

  private:
  const std::string& _internal_evrule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_evrule(
      const std::string& value);
  std::string* _internal_mutable_evrule();

  public:
  // optional string underSymbol = 19;
  bool has_undersymbol() const;
  void clear_undersymbol() ;
  const std::string& undersymbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_undersymbol(Arg_&& arg, Args_... args);
  std::string* mutable_undersymbol();
  PROTOBUF_NODISCARD std::string* release_undersymbol();
  void set_allocated_undersymbol(std::string* value);

  private:
  const std::string& _internal_undersymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_undersymbol(
      const std::string& value);
  std::string* _internal_mutable_undersymbol();

  public:
  // optional string underSecType = 20;
  bool has_undersectype() const;
  void clear_undersectype() ;
  const std::string& undersectype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_undersectype(Arg_&& arg, Args_... args);
  std::string* mutable_undersectype();
  PROTOBUF_NODISCARD std::string* release_undersectype();
  void set_allocated_undersectype(std::string* value);

  private:
  const std::string& _internal_undersectype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_undersectype(
      const std::string& value);
  std::string* _internal_mutable_undersectype();

  public:
  // optional string marketRuleIds = 21;
  bool has_marketruleids() const;
  void clear_marketruleids() ;
  const std::string& marketruleids() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_marketruleids(Arg_&& arg, Args_... args);
  std::string* mutable_marketruleids();
  PROTOBUF_NODISCARD std::string* release_marketruleids();
  void set_allocated_marketruleids(std::string* value);

  private:
  const std::string& _internal_marketruleids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketruleids(
      const std::string& value);
  std::string* _internal_mutable_marketruleids();

  public:
  // optional string realExpirationDate = 22;
  bool has_realexpirationdate() const;
  void clear_realexpirationdate() ;
  const std::string& realexpirationdate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_realexpirationdate(Arg_&& arg, Args_... args);
  std::string* mutable_realexpirationdate();
  PROTOBUF_NODISCARD std::string* release_realexpirationdate();
  void set_allocated_realexpirationdate(std::string* value);

  private:
  const std::string& _internal_realexpirationdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realexpirationdate(
      const std::string& value);
  std::string* _internal_mutable_realexpirationdate();

  public:
  // optional string stockType = 23;
  bool has_stocktype() const;
  void clear_stocktype() ;
  const std::string& stocktype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stocktype(Arg_&& arg, Args_... args);
  std::string* mutable_stocktype();
  PROTOBUF_NODISCARD std::string* release_stocktype();
  void set_allocated_stocktype(std::string* value);

  private:
  const std::string& _internal_stocktype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stocktype(
      const std::string& value);
  std::string* _internal_mutable_stocktype();

  public:
  // optional string minSize = 24;
  bool has_minsize() const;
  void clear_minsize() ;
  const std::string& minsize() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_minsize(Arg_&& arg, Args_... args);
  std::string* mutable_minsize();
  PROTOBUF_NODISCARD std::string* release_minsize();
  void set_allocated_minsize(std::string* value);

  private:
  const std::string& _internal_minsize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minsize(
      const std::string& value);
  std::string* _internal_mutable_minsize();

  public:
  // optional string sizeIncrement = 25;
  bool has_sizeincrement() const;
  void clear_sizeincrement() ;
  const std::string& sizeincrement() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sizeincrement(Arg_&& arg, Args_... args);
  std::string* mutable_sizeincrement();
  PROTOBUF_NODISCARD std::string* release_sizeincrement();
  void set_allocated_sizeincrement(std::string* value);

  private:
  const std::string& _internal_sizeincrement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sizeincrement(
      const std::string& value);
  std::string* _internal_mutable_sizeincrement();

  public:
  // optional string suggestedSizeIncrement = 26;
  bool has_suggestedsizeincrement() const;
  void clear_suggestedsizeincrement() ;
  const std::string& suggestedsizeincrement() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_suggestedsizeincrement(Arg_&& arg, Args_... args);
  std::string* mutable_suggestedsizeincrement();
  PROTOBUF_NODISCARD std::string* release_suggestedsizeincrement();
  void set_allocated_suggestedsizeincrement(std::string* value);

  private:
  const std::string& _internal_suggestedsizeincrement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suggestedsizeincrement(
      const std::string& value);
  std::string* _internal_mutable_suggestedsizeincrement();

  public:
  // optional string fundName = 27;
  bool has_fundname() const;
  void clear_fundname() ;
  const std::string& fundname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundname(Arg_&& arg, Args_... args);
  std::string* mutable_fundname();
  PROTOBUF_NODISCARD std::string* release_fundname();
  void set_allocated_fundname(std::string* value);

  private:
  const std::string& _internal_fundname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundname(
      const std::string& value);
  std::string* _internal_mutable_fundname();

  public:
  // optional string fundFamily = 28;
  bool has_fundfamily() const;
  void clear_fundfamily() ;
  const std::string& fundfamily() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundfamily(Arg_&& arg, Args_... args);
  std::string* mutable_fundfamily();
  PROTOBUF_NODISCARD std::string* release_fundfamily();
  void set_allocated_fundfamily(std::string* value);

  private:
  const std::string& _internal_fundfamily() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundfamily(
      const std::string& value);
  std::string* _internal_mutable_fundfamily();

  public:
  // optional string fundType = 29;
  bool has_fundtype() const;
  void clear_fundtype() ;
  const std::string& fundtype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundtype(Arg_&& arg, Args_... args);
  std::string* mutable_fundtype();
  PROTOBUF_NODISCARD std::string* release_fundtype();
  void set_allocated_fundtype(std::string* value);

  private:
  const std::string& _internal_fundtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundtype(
      const std::string& value);
  std::string* _internal_mutable_fundtype();

  public:
  // optional string fundFrontLoad = 30;
  bool has_fundfrontload() const;
  void clear_fundfrontload() ;
  const std::string& fundfrontload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundfrontload(Arg_&& arg, Args_... args);
  std::string* mutable_fundfrontload();
  PROTOBUF_NODISCARD std::string* release_fundfrontload();
  void set_allocated_fundfrontload(std::string* value);

  private:
  const std::string& _internal_fundfrontload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundfrontload(
      const std::string& value);
  std::string* _internal_mutable_fundfrontload();

  public:
  // optional string fundBackLoad = 31;
  bool has_fundbackload() const;
  void clear_fundbackload() ;
  const std::string& fundbackload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundbackload(Arg_&& arg, Args_... args);
  std::string* mutable_fundbackload();
  PROTOBUF_NODISCARD std::string* release_fundbackload();
  void set_allocated_fundbackload(std::string* value);

  private:
  const std::string& _internal_fundbackload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundbackload(
      const std::string& value);
  std::string* _internal_mutable_fundbackload();

  public:
  // optional string fundBackLoadTimeInterval = 32;
  bool has_fundbackloadtimeinterval() const;
  void clear_fundbackloadtimeinterval() ;
  const std::string& fundbackloadtimeinterval() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundbackloadtimeinterval(Arg_&& arg, Args_... args);
  std::string* mutable_fundbackloadtimeinterval();
  PROTOBUF_NODISCARD std::string* release_fundbackloadtimeinterval();
  void set_allocated_fundbackloadtimeinterval(std::string* value);

  private:
  const std::string& _internal_fundbackloadtimeinterval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundbackloadtimeinterval(
      const std::string& value);
  std::string* _internal_mutable_fundbackloadtimeinterval();

  public:
  // optional string fundManagementFee = 33;
  bool has_fundmanagementfee() const;
  void clear_fundmanagementfee() ;
  const std::string& fundmanagementfee() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundmanagementfee(Arg_&& arg, Args_... args);
  std::string* mutable_fundmanagementfee();
  PROTOBUF_NODISCARD std::string* release_fundmanagementfee();
  void set_allocated_fundmanagementfee(std::string* value);

  private:
  const std::string& _internal_fundmanagementfee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundmanagementfee(
      const std::string& value);
  std::string* _internal_mutable_fundmanagementfee();

  public:
  // optional string fundNotifyAmount = 37;
  bool has_fundnotifyamount() const;
  void clear_fundnotifyamount() ;
  const std::string& fundnotifyamount() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundnotifyamount(Arg_&& arg, Args_... args);
  std::string* mutable_fundnotifyamount();
  PROTOBUF_NODISCARD std::string* release_fundnotifyamount();
  void set_allocated_fundnotifyamount(std::string* value);

  private:
  const std::string& _internal_fundnotifyamount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundnotifyamount(
      const std::string& value);
  std::string* _internal_mutable_fundnotifyamount();

  public:
  // optional string fundMinimumInitialPurchase = 38;
  bool has_fundminimuminitialpurchase() const;
  void clear_fundminimuminitialpurchase() ;
  const std::string& fundminimuminitialpurchase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundminimuminitialpurchase(Arg_&& arg, Args_... args);
  std::string* mutable_fundminimuminitialpurchase();
  PROTOBUF_NODISCARD std::string* release_fundminimuminitialpurchase();
  void set_allocated_fundminimuminitialpurchase(std::string* value);

  private:
  const std::string& _internal_fundminimuminitialpurchase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundminimuminitialpurchase(
      const std::string& value);
  std::string* _internal_mutable_fundminimuminitialpurchase();

  public:
  // optional string fundMinimumSubsequentPurchase = 39;
  bool has_fundminimumsubsequentpurchase() const;
  void clear_fundminimumsubsequentpurchase() ;
  const std::string& fundminimumsubsequentpurchase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundminimumsubsequentpurchase(Arg_&& arg, Args_... args);
  std::string* mutable_fundminimumsubsequentpurchase();
  PROTOBUF_NODISCARD std::string* release_fundminimumsubsequentpurchase();
  void set_allocated_fundminimumsubsequentpurchase(std::string* value);

  private:
  const std::string& _internal_fundminimumsubsequentpurchase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundminimumsubsequentpurchase(
      const std::string& value);
  std::string* _internal_mutable_fundminimumsubsequentpurchase();

  public:
  // optional string fundBlueSkyStates = 40;
  bool has_fundblueskystates() const;
  void clear_fundblueskystates() ;
  const std::string& fundblueskystates() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundblueskystates(Arg_&& arg, Args_... args);
  std::string* mutable_fundblueskystates();
  PROTOBUF_NODISCARD std::string* release_fundblueskystates();
  void set_allocated_fundblueskystates(std::string* value);

  private:
  const std::string& _internal_fundblueskystates() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundblueskystates(
      const std::string& value);
  std::string* _internal_mutable_fundblueskystates();

  public:
  // optional string fundBlueSkyTerritories = 41;
  bool has_fundblueskyterritories() const;
  void clear_fundblueskyterritories() ;
  const std::string& fundblueskyterritories() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundblueskyterritories(Arg_&& arg, Args_... args);
  std::string* mutable_fundblueskyterritories();
  PROTOBUF_NODISCARD std::string* release_fundblueskyterritories();
  void set_allocated_fundblueskyterritories(std::string* value);

  private:
  const std::string& _internal_fundblueskyterritories() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundblueskyterritories(
      const std::string& value);
  std::string* _internal_mutable_fundblueskyterritories();

  public:
  // optional string fundDistributionPolicyIndicator = 42;
  bool has_funddistributionpolicyindicator() const;
  void clear_funddistributionpolicyindicator() ;
  const std::string& funddistributionpolicyindicator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_funddistributionpolicyindicator(Arg_&& arg, Args_... args);
  std::string* mutable_funddistributionpolicyindicator();
  PROTOBUF_NODISCARD std::string* release_funddistributionpolicyindicator();
  void set_allocated_funddistributionpolicyindicator(std::string* value);

  private:
  const std::string& _internal_funddistributionpolicyindicator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funddistributionpolicyindicator(
      const std::string& value);
  std::string* _internal_mutable_funddistributionpolicyindicator();

  public:
  // optional string fundAssetType = 43;
  bool has_fundassettype() const;
  void clear_fundassettype() ;
  const std::string& fundassettype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fundassettype(Arg_&& arg, Args_... args);
  std::string* mutable_fundassettype();
  PROTOBUF_NODISCARD std::string* release_fundassettype();
  void set_allocated_fundassettype(std::string* value);

  private:
  const std::string& _internal_fundassettype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundassettype(
      const std::string& value);
  std::string* _internal_mutable_fundassettype();

  public:
  // optional string cusip = 44;
  bool has_cusip() const;
  void clear_cusip() ;
  const std::string& cusip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cusip(Arg_&& arg, Args_... args);
  std::string* mutable_cusip();
  PROTOBUF_NODISCARD std::string* release_cusip();
  void set_allocated_cusip(std::string* value);

  private:
  const std::string& _internal_cusip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cusip(
      const std::string& value);
  std::string* _internal_mutable_cusip();

  public:
  // optional string issueDate = 45;
  bool has_issuedate() const;
  void clear_issuedate() ;
  const std::string& issuedate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_issuedate(Arg_&& arg, Args_... args);
  std::string* mutable_issuedate();
  PROTOBUF_NODISCARD std::string* release_issuedate();
  void set_allocated_issuedate(std::string* value);

  private:
  const std::string& _internal_issuedate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuedate(
      const std::string& value);
  std::string* _internal_mutable_issuedate();

  public:
  // optional string ratings = 46;
  bool has_ratings() const;
  void clear_ratings() ;
  const std::string& ratings() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ratings(Arg_&& arg, Args_... args);
  std::string* mutable_ratings();
  PROTOBUF_NODISCARD std::string* release_ratings();
  void set_allocated_ratings(std::string* value);

  private:
  const std::string& _internal_ratings() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ratings(
      const std::string& value);
  std::string* _internal_mutable_ratings();

  public:
  // optional string bondType = 47;
  bool has_bondtype() const;
  void clear_bondtype() ;
  const std::string& bondtype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bondtype(Arg_&& arg, Args_... args);
  std::string* mutable_bondtype();
  PROTOBUF_NODISCARD std::string* release_bondtype();
  void set_allocated_bondtype(std::string* value);

  private:
  const std::string& _internal_bondtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bondtype(
      const std::string& value);
  std::string* _internal_mutable_bondtype();

  public:
  // optional string couponType = 49;
  bool has_coupontype() const;
  void clear_coupontype() ;
  const std::string& coupontype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_coupontype(Arg_&& arg, Args_... args);
  std::string* mutable_coupontype();
  PROTOBUF_NODISCARD std::string* release_coupontype();
  void set_allocated_coupontype(std::string* value);

  private:
  const std::string& _internal_coupontype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coupontype(
      const std::string& value);
  std::string* _internal_mutable_coupontype();

  public:
  // optional string descAppend = 53;
  bool has_descappend() const;
  void clear_descappend() ;
  const std::string& descappend() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_descappend(Arg_&& arg, Args_... args);
  std::string* mutable_descappend();
  PROTOBUF_NODISCARD std::string* release_descappend();
  void set_allocated_descappend(std::string* value);

  private:
  const std::string& _internal_descappend() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_descappend(
      const std::string& value);
  std::string* _internal_mutable_descappend();

  public:
  // optional string nextOptionDate = 54;
  bool has_nextoptiondate() const;
  void clear_nextoptiondate() ;
  const std::string& nextoptiondate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nextoptiondate(Arg_&& arg, Args_... args);
  std::string* mutable_nextoptiondate();
  PROTOBUF_NODISCARD std::string* release_nextoptiondate();
  void set_allocated_nextoptiondate(std::string* value);

  private:
  const std::string& _internal_nextoptiondate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextoptiondate(
      const std::string& value);
  std::string* _internal_mutable_nextoptiondate();

  public:
  // optional string nextOptionType = 55;
  bool has_nextoptiontype() const;
  void clear_nextoptiontype() ;
  const std::string& nextoptiontype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nextoptiontype(Arg_&& arg, Args_... args);
  std::string* mutable_nextoptiontype();
  PROTOBUF_NODISCARD std::string* release_nextoptiontype();
  void set_allocated_nextoptiontype(std::string* value);

  private:
  const std::string& _internal_nextoptiontype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextoptiontype(
      const std::string& value);
  std::string* _internal_mutable_nextoptiontype();

  public:
  // optional string bondNotes = 57;
  bool has_bondnotes() const;
  void clear_bondnotes() ;
  const std::string& bondnotes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bondnotes(Arg_&& arg, Args_... args);
  std::string* mutable_bondnotes();
  PROTOBUF_NODISCARD std::string* release_bondnotes();
  void set_allocated_bondnotes(std::string* value);

  private:
  const std::string& _internal_bondnotes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bondnotes(
      const std::string& value);
  std::string* _internal_mutable_bondnotes();

  public:
  // optional int32 priceMagnifier = 5;
  bool has_pricemagnifier() const;
  void clear_pricemagnifier() ;
  ::int32_t pricemagnifier() const;
  void set_pricemagnifier(::int32_t value);

  private:
  ::int32_t _internal_pricemagnifier() const;
  void _internal_set_pricemagnifier(::int32_t value);

  public:
  // optional int32 underConId = 6;
  bool has_underconid() const;
  void clear_underconid() ;
  ::int32_t underconid() const;
  void set_underconid(::int32_t value);

  private:
  ::int32_t _internal_underconid() const;
  void _internal_set_underconid(::int32_t value);

  public:
  // optional double evMultiplier = 16;
  bool has_evmultiplier() const;
  void clear_evmultiplier() ;
  double evmultiplier() const;
  void set_evmultiplier(double value);

  private:
  double _internal_evmultiplier() const;
  void _internal_set_evmultiplier(double value);

  public:
  // optional int32 aggGroup = 18;
  bool has_agggroup() const;
  void clear_agggroup() ;
  ::int32_t agggroup() const;
  void set_agggroup(::int32_t value);

  private:
  ::int32_t _internal_agggroup() const;
  void _internal_set_agggroup(::int32_t value);

  public:
  // optional bool fundClosed = 34;
  bool has_fundclosed() const;
  void clear_fundclosed() ;
  bool fundclosed() const;
  void set_fundclosed(bool value);

  private:
  bool _internal_fundclosed() const;
  void _internal_set_fundclosed(bool value);

  public:
  // optional bool fundClosedForNewInvestors = 35;
  bool has_fundclosedfornewinvestors() const;
  void clear_fundclosedfornewinvestors() ;
  bool fundclosedfornewinvestors() const;
  void set_fundclosedfornewinvestors(bool value);

  private:
  bool _internal_fundclosedfornewinvestors() const;
  void _internal_set_fundclosedfornewinvestors(bool value);

  public:
  // optional bool fundClosedForNewMoney = 36;
  bool has_fundclosedfornewmoney() const;
  void clear_fundclosedfornewmoney() ;
  bool fundclosedfornewmoney() const;
  void set_fundclosedfornewmoney(bool value);

  private:
  bool _internal_fundclosedfornewmoney() const;
  void _internal_set_fundclosedfornewmoney(bool value);

  public:
  // optional bool convertible = 50;
  bool has_convertible() const;
  void clear_convertible() ;
  bool convertible() const;
  void set_convertible(bool value);

  private:
  bool _internal_convertible() const;
  void _internal_set_convertible(bool value);

  public:
  // optional double coupon = 48;
  bool has_coupon() const;
  void clear_coupon() ;
  double coupon() const;
  void set_coupon(double value);

  private:
  double _internal_coupon() const;
  void _internal_set_coupon(double value);

  public:
  // optional bool callable = 51;
  bool has_callable() const;
  void clear_callable() ;
  bool callable() const;
  void set_callable(bool value);

  private:
  bool _internal_callable() const;
  void _internal_set_callable(bool value);

  public:
  // optional bool puttable = 52;
  bool has_puttable() const;
  void clear_puttable() ;
  bool puttable() const;
  void set_puttable(bool value);

  private:
  bool _internal_puttable() const;
  void _internal_set_puttable(bool value);

  public:
  // optional bool nextOptionPartial = 56;
  bool has_nextoptionpartial() const;
  void clear_nextoptionpartial() ;
  bool nextoptionpartial() const;
  void set_nextoptionpartial(bool value);

  private:
  bool _internal_nextoptionpartial() const;
  void _internal_set_nextoptionpartial(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protobuf.ContractDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 58, 2,
      663, 9>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractDetails& from_msg);
    ::google::protobuf::internal::HasBits<2> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<ContractDetails_SecIdListEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secidlist_;
    ::google::protobuf::RepeatedPtrField< ::protobuf::IneligibilityReason > ineligibilityreasonlist_;
    ::google::protobuf::internal::ArenaStringPtr marketname_;
    ::google::protobuf::internal::ArenaStringPtr mintick_;
    ::google::protobuf::internal::ArenaStringPtr ordertypes_;
    ::google::protobuf::internal::ArenaStringPtr validexchanges_;
    ::google::protobuf::internal::ArenaStringPtr longname_;
    ::google::protobuf::internal::ArenaStringPtr contractmonth_;
    ::google::protobuf::internal::ArenaStringPtr industry_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr subcategory_;
    ::google::protobuf::internal::ArenaStringPtr timezoneid_;
    ::google::protobuf::internal::ArenaStringPtr tradinghours_;
    ::google::protobuf::internal::ArenaStringPtr liquidhours_;
    ::google::protobuf::internal::ArenaStringPtr evrule_;
    ::google::protobuf::internal::ArenaStringPtr undersymbol_;
    ::google::protobuf::internal::ArenaStringPtr undersectype_;
    ::google::protobuf::internal::ArenaStringPtr marketruleids_;
    ::google::protobuf::internal::ArenaStringPtr realexpirationdate_;
    ::google::protobuf::internal::ArenaStringPtr stocktype_;
    ::google::protobuf::internal::ArenaStringPtr minsize_;
    ::google::protobuf::internal::ArenaStringPtr sizeincrement_;
    ::google::protobuf::internal::ArenaStringPtr suggestedsizeincrement_;
    ::google::protobuf::internal::ArenaStringPtr fundname_;
    ::google::protobuf::internal::ArenaStringPtr fundfamily_;
    ::google::protobuf::internal::ArenaStringPtr fundtype_;
    ::google::protobuf::internal::ArenaStringPtr fundfrontload_;
    ::google::protobuf::internal::ArenaStringPtr fundbackload_;
    ::google::protobuf::internal::ArenaStringPtr fundbackloadtimeinterval_;
    ::google::protobuf::internal::ArenaStringPtr fundmanagementfee_;
    ::google::protobuf::internal::ArenaStringPtr fundnotifyamount_;
    ::google::protobuf::internal::ArenaStringPtr fundminimuminitialpurchase_;
    ::google::protobuf::internal::ArenaStringPtr fundminimumsubsequentpurchase_;
    ::google::protobuf::internal::ArenaStringPtr fundblueskystates_;
    ::google::protobuf::internal::ArenaStringPtr fundblueskyterritories_;
    ::google::protobuf::internal::ArenaStringPtr funddistributionpolicyindicator_;
    ::google::protobuf::internal::ArenaStringPtr fundassettype_;
    ::google::protobuf::internal::ArenaStringPtr cusip_;
    ::google::protobuf::internal::ArenaStringPtr issuedate_;
    ::google::protobuf::internal::ArenaStringPtr ratings_;
    ::google::protobuf::internal::ArenaStringPtr bondtype_;
    ::google::protobuf::internal::ArenaStringPtr coupontype_;
    ::google::protobuf::internal::ArenaStringPtr descappend_;
    ::google::protobuf::internal::ArenaStringPtr nextoptiondate_;
    ::google::protobuf::internal::ArenaStringPtr nextoptiontype_;
    ::google::protobuf::internal::ArenaStringPtr bondnotes_;
    ::int32_t pricemagnifier_;
    ::int32_t underconid_;
    double evmultiplier_;
    ::int32_t agggroup_;
    bool fundclosed_;
    bool fundclosedfornewinvestors_;
    bool fundclosedfornewmoney_;
    bool convertible_;
    double coupon_;
    bool callable_;
    bool puttable_;
    bool nextoptionpartial_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ContractDetails_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractDetails

// optional string marketName = 1;
inline bool ContractDetails::has_marketname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ContractDetails::clear_marketname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.marketname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractDetails::marketname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.marketName)
  return _internal_marketname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_marketname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.marketName)
}
inline std::string* ContractDetails::mutable_marketname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_marketname();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.marketName)
  return _s;
}
inline const std::string& ContractDetails::_internal_marketname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.marketname_.Get();
}
inline void ContractDetails::_internal_set_marketname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketname_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_marketname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.marketname_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_marketname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.marketName)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.marketname_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.marketname_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_marketname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.marketname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.marketname_.IsDefault()) {
    _impl_.marketname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.marketName)
}

// optional string minTick = 2;
inline bool ContractDetails::has_mintick() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ContractDetails::clear_mintick() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mintick_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractDetails::mintick() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.minTick)
  return _internal_mintick();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_mintick(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mintick_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.minTick)
}
inline std::string* ContractDetails::mutable_mintick() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mintick();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.minTick)
  return _s;
}
inline const std::string& ContractDetails::_internal_mintick() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mintick_.Get();
}
inline void ContractDetails::_internal_set_mintick(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mintick_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_mintick() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mintick_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_mintick() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.minTick)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.mintick_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.mintick_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_mintick(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mintick_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mintick_.IsDefault()) {
    _impl_.mintick_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.minTick)
}

// optional string orderTypes = 3;
inline bool ContractDetails::has_ordertypes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ContractDetails::clear_ordertypes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ordertypes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContractDetails::ordertypes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.orderTypes)
  return _internal_ordertypes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_ordertypes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ordertypes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.orderTypes)
}
inline std::string* ContractDetails::mutable_ordertypes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ordertypes();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.orderTypes)
  return _s;
}
inline const std::string& ContractDetails::_internal_ordertypes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ordertypes_.Get();
}
inline void ContractDetails::_internal_set_ordertypes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ordertypes_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_ordertypes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ordertypes_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_ordertypes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.orderTypes)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ordertypes_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ordertypes_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_ordertypes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ordertypes_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ordertypes_.IsDefault()) {
    _impl_.ordertypes_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.orderTypes)
}

// optional string validExchanges = 4;
inline bool ContractDetails::has_validexchanges() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ContractDetails::clear_validexchanges() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validexchanges_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContractDetails::validexchanges() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.validExchanges)
  return _internal_validexchanges();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_validexchanges(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.validexchanges_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.validExchanges)
}
inline std::string* ContractDetails::mutable_validexchanges() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validexchanges();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.validExchanges)
  return _s;
}
inline const std::string& ContractDetails::_internal_validexchanges() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validexchanges_.Get();
}
inline void ContractDetails::_internal_set_validexchanges(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.validexchanges_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_validexchanges() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.validexchanges_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_validexchanges() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.validExchanges)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.validexchanges_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.validexchanges_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_validexchanges(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.validexchanges_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validexchanges_.IsDefault()) {
    _impl_.validexchanges_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.validExchanges)
}

// optional int32 priceMagnifier = 5;
inline bool ContractDetails::has_pricemagnifier() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline void ContractDetails::clear_pricemagnifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pricemagnifier_ = 0;
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline ::int32_t ContractDetails::pricemagnifier() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.priceMagnifier)
  return _internal_pricemagnifier();
}
inline void ContractDetails::set_pricemagnifier(::int32_t value) {
  _internal_set_pricemagnifier(value);
  _impl_._has_bits_[1] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.priceMagnifier)
}
inline ::int32_t ContractDetails::_internal_pricemagnifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pricemagnifier_;
}
inline void ContractDetails::_internal_set_pricemagnifier(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pricemagnifier_ = value;
}

// optional int32 underConId = 6;
inline bool ContractDetails::has_underconid() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline void ContractDetails::clear_underconid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.underconid_ = 0;
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline ::int32_t ContractDetails::underconid() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.underConId)
  return _internal_underconid();
}
inline void ContractDetails::set_underconid(::int32_t value) {
  _internal_set_underconid(value);
  _impl_._has_bits_[1] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.underConId)
}
inline ::int32_t ContractDetails::_internal_underconid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.underconid_;
}
inline void ContractDetails::_internal_set_underconid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.underconid_ = value;
}

// optional string longName = 7;
inline bool ContractDetails::has_longname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ContractDetails::clear_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ContractDetails::longname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.longName)
  return _internal_longname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_longname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.longname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.longName)
}
inline std::string* ContractDetails::mutable_longname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_longname();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.longName)
  return _s;
}
inline const std::string& ContractDetails::_internal_longname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longname_.Get();
}
inline void ContractDetails::_internal_set_longname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.longname_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.longname_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.longName)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.longname_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.longname_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_longname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.longname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.longname_.IsDefault()) {
    _impl_.longname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.longName)
}

// optional string contractMonth = 8;
inline bool ContractDetails::has_contractmonth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ContractDetails::clear_contractmonth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contractmonth_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ContractDetails::contractmonth() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.contractMonth)
  return _internal_contractmonth();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_contractmonth(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.contractmonth_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.contractMonth)
}
inline std::string* ContractDetails::mutable_contractmonth() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contractmonth();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.contractMonth)
  return _s;
}
inline const std::string& ContractDetails::_internal_contractmonth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contractmonth_.Get();
}
inline void ContractDetails::_internal_set_contractmonth(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.contractmonth_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_contractmonth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.contractmonth_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_contractmonth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.contractMonth)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.contractmonth_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.contractmonth_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_contractmonth(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.contractmonth_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contractmonth_.IsDefault()) {
    _impl_.contractmonth_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.contractMonth)
}

// optional string industry = 9;
inline bool ContractDetails::has_industry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ContractDetails::clear_industry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.industry_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ContractDetails::industry() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.industry)
  return _internal_industry();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_industry(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.industry_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.industry)
}
inline std::string* ContractDetails::mutable_industry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_industry();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.industry)
  return _s;
}
inline const std::string& ContractDetails::_internal_industry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.industry_.Get();
}
inline void ContractDetails::_internal_set_industry(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.industry_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_industry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.industry_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_industry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.industry)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.industry_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.industry_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_industry(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.industry_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.industry_.IsDefault()) {
    _impl_.industry_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.industry)
}

// optional string category = 10;
inline bool ContractDetails::has_category() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ContractDetails::clear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ContractDetails::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_category(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.category)
}
inline std::string* ContractDetails::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.category)
  return _s;
}
inline const std::string& ContractDetails::_internal_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_.Get();
}
inline void ContractDetails::_internal_set_category(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.category_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.category)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.category_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.category_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_category(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.category_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.category)
}

// optional string subcategory = 11;
inline bool ContractDetails::has_subcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ContractDetails::clear_subcategory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subcategory_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ContractDetails::subcategory() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.subcategory)
  return _internal_subcategory();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_subcategory(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.subcategory_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.subcategory)
}
inline std::string* ContractDetails::mutable_subcategory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subcategory();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.subcategory)
  return _s;
}
inline const std::string& ContractDetails::_internal_subcategory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subcategory_.Get();
}
inline void ContractDetails::_internal_set_subcategory(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.subcategory_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_subcategory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.subcategory_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_subcategory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.subcategory)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.subcategory_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.subcategory_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_subcategory(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.subcategory_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.subcategory_.IsDefault()) {
    _impl_.subcategory_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.subcategory)
}

// optional string timeZoneId = 12;
inline bool ContractDetails::has_timezoneid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ContractDetails::clear_timezoneid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timezoneid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ContractDetails::timezoneid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.timeZoneId)
  return _internal_timezoneid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_timezoneid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.timezoneid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.timeZoneId)
}
inline std::string* ContractDetails::mutable_timezoneid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timezoneid();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.timeZoneId)
  return _s;
}
inline const std::string& ContractDetails::_internal_timezoneid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timezoneid_.Get();
}
inline void ContractDetails::_internal_set_timezoneid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.timezoneid_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_timezoneid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.timezoneid_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_timezoneid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.timeZoneId)
  if ((_impl_._has_bits_[0] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* released = _impl_.timezoneid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.timezoneid_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_timezoneid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.timezoneid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timezoneid_.IsDefault()) {
    _impl_.timezoneid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.timeZoneId)
}

// optional string tradingHours = 13;
inline bool ContractDetails::has_tradinghours() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ContractDetails::clear_tradinghours() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tradinghours_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ContractDetails::tradinghours() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.tradingHours)
  return _internal_tradinghours();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_tradinghours(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.tradinghours_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.tradingHours)
}
inline std::string* ContractDetails::mutable_tradinghours() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tradinghours();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.tradingHours)
  return _s;
}
inline const std::string& ContractDetails::_internal_tradinghours() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tradinghours_.Get();
}
inline void ContractDetails::_internal_set_tradinghours(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.tradinghours_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_tradinghours() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.tradinghours_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_tradinghours() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.tradingHours)
  if ((_impl_._has_bits_[0] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* released = _impl_.tradinghours_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.tradinghours_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_tradinghours(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.tradinghours_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.tradinghours_.IsDefault()) {
    _impl_.tradinghours_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.tradingHours)
}

// optional string liquidHours = 14;
inline bool ContractDetails::has_liquidhours() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void ContractDetails::clear_liquidhours() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.liquidhours_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ContractDetails::liquidhours() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.liquidHours)
  return _internal_liquidhours();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_liquidhours(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.liquidhours_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.liquidHours)
}
inline std::string* ContractDetails::mutable_liquidhours() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_liquidhours();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.liquidHours)
  return _s;
}
inline const std::string& ContractDetails::_internal_liquidhours() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.liquidhours_.Get();
}
inline void ContractDetails::_internal_set_liquidhours(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.liquidhours_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_liquidhours() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.liquidhours_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_liquidhours() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.liquidHours)
  if ((_impl_._has_bits_[0] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* released = _impl_.liquidhours_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.liquidhours_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_liquidhours(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.liquidhours_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.liquidhours_.IsDefault()) {
    _impl_.liquidhours_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.liquidHours)
}

// optional string evRule = 15;
inline bool ContractDetails::has_evrule() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void ContractDetails::clear_evrule() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.evrule_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& ContractDetails::evrule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.evRule)
  return _internal_evrule();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_evrule(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.evrule_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.evRule)
}
inline std::string* ContractDetails::mutable_evrule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_evrule();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.evRule)
  return _s;
}
inline const std::string& ContractDetails::_internal_evrule() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.evrule_.Get();
}
inline void ContractDetails::_internal_set_evrule(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.evrule_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_evrule() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.evrule_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_evrule() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.evRule)
  if ((_impl_._has_bits_[0] & 0x00001000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* released = _impl_.evrule_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.evrule_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_evrule(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.evrule_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.evrule_.IsDefault()) {
    _impl_.evrule_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.evRule)
}

// optional double evMultiplier = 16;
inline bool ContractDetails::has_evmultiplier() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline void ContractDetails::clear_evmultiplier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.evmultiplier_ = 0;
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline double ContractDetails::evmultiplier() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.evMultiplier)
  return _internal_evmultiplier();
}
inline void ContractDetails::set_evmultiplier(double value) {
  _internal_set_evmultiplier(value);
  _impl_._has_bits_[1] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.evMultiplier)
}
inline double ContractDetails::_internal_evmultiplier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.evmultiplier_;
}
inline void ContractDetails::_internal_set_evmultiplier(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.evmultiplier_ = value;
}

// map<string, string> secIdList = 17;
inline int ContractDetails::_internal_secidlist_size() const {
  return _internal_secidlist().size();
}
inline int ContractDetails::secidlist_size() const {
  return _internal_secidlist_size();
}
inline void ContractDetails::clear_secidlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secidlist_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractDetails::_internal_secidlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secidlist_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractDetails::secidlist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:protobuf.ContractDetails.secIdList)
  return _internal_secidlist();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractDetails::_internal_mutable_secidlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secidlist_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractDetails::mutable_secidlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:protobuf.ContractDetails.secIdList)
  return _internal_mutable_secidlist();
}

// optional int32 aggGroup = 18;
inline bool ContractDetails::has_agggroup() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline void ContractDetails::clear_agggroup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agggroup_ = 0;
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline ::int32_t ContractDetails::agggroup() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.aggGroup)
  return _internal_agggroup();
}
inline void ContractDetails::set_agggroup(::int32_t value) {
  _internal_set_agggroup(value);
  _impl_._has_bits_[1] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.aggGroup)
}
inline ::int32_t ContractDetails::_internal_agggroup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agggroup_;
}
inline void ContractDetails::_internal_set_agggroup(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agggroup_ = value;
}

// optional string underSymbol = 19;
inline bool ContractDetails::has_undersymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void ContractDetails::clear_undersymbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.undersymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& ContractDetails::undersymbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.underSymbol)
  return _internal_undersymbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_undersymbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.undersymbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.underSymbol)
}
inline std::string* ContractDetails::mutable_undersymbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_undersymbol();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.underSymbol)
  return _s;
}
inline const std::string& ContractDetails::_internal_undersymbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.undersymbol_.Get();
}
inline void ContractDetails::_internal_set_undersymbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.undersymbol_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_undersymbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.undersymbol_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_undersymbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.underSymbol)
  if ((_impl_._has_bits_[0] & 0x00002000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* released = _impl_.undersymbol_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.undersymbol_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_undersymbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.undersymbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.undersymbol_.IsDefault()) {
    _impl_.undersymbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.underSymbol)
}

// optional string underSecType = 20;
inline bool ContractDetails::has_undersectype() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void ContractDetails::clear_undersectype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.undersectype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& ContractDetails::undersectype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.underSecType)
  return _internal_undersectype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_undersectype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.undersectype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.underSecType)
}
inline std::string* ContractDetails::mutable_undersectype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_undersectype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.underSecType)
  return _s;
}
inline const std::string& ContractDetails::_internal_undersectype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.undersectype_.Get();
}
inline void ContractDetails::_internal_set_undersectype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.undersectype_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_undersectype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.undersectype_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_undersectype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.underSecType)
  if ((_impl_._has_bits_[0] & 0x00004000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* released = _impl_.undersectype_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.undersectype_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_undersectype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.undersectype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.undersectype_.IsDefault()) {
    _impl_.undersectype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.underSecType)
}

// optional string marketRuleIds = 21;
inline bool ContractDetails::has_marketruleids() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void ContractDetails::clear_marketruleids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.marketruleids_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& ContractDetails::marketruleids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.marketRuleIds)
  return _internal_marketruleids();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_marketruleids(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.marketruleids_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.marketRuleIds)
}
inline std::string* ContractDetails::mutable_marketruleids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_marketruleids();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.marketRuleIds)
  return _s;
}
inline const std::string& ContractDetails::_internal_marketruleids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.marketruleids_.Get();
}
inline void ContractDetails::_internal_set_marketruleids(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.marketruleids_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_marketruleids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.marketruleids_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_marketruleids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.marketRuleIds)
  if ((_impl_._has_bits_[0] & 0x00008000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* released = _impl_.marketruleids_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.marketruleids_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_marketruleids(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.marketruleids_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.marketruleids_.IsDefault()) {
    _impl_.marketruleids_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.marketRuleIds)
}

// optional string realExpirationDate = 22;
inline bool ContractDetails::has_realexpirationdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void ContractDetails::clear_realexpirationdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.realexpirationdate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& ContractDetails::realexpirationdate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.realExpirationDate)
  return _internal_realexpirationdate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_realexpirationdate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.realexpirationdate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.realExpirationDate)
}
inline std::string* ContractDetails::mutable_realexpirationdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_realexpirationdate();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.realExpirationDate)
  return _s;
}
inline const std::string& ContractDetails::_internal_realexpirationdate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.realexpirationdate_.Get();
}
inline void ContractDetails::_internal_set_realexpirationdate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.realexpirationdate_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_realexpirationdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.realexpirationdate_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_realexpirationdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.realExpirationDate)
  if ((_impl_._has_bits_[0] & 0x00010000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* released = _impl_.realexpirationdate_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.realexpirationdate_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_realexpirationdate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.realexpirationdate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.realexpirationdate_.IsDefault()) {
    _impl_.realexpirationdate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.realExpirationDate)
}

// optional string stockType = 23;
inline bool ContractDetails::has_stocktype() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void ContractDetails::clear_stocktype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stocktype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& ContractDetails::stocktype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.stockType)
  return _internal_stocktype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_stocktype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.stocktype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.stockType)
}
inline std::string* ContractDetails::mutable_stocktype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stocktype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.stockType)
  return _s;
}
inline const std::string& ContractDetails::_internal_stocktype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stocktype_.Get();
}
inline void ContractDetails::_internal_set_stocktype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.stocktype_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_stocktype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.stocktype_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_stocktype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.stockType)
  if ((_impl_._has_bits_[0] & 0x00020000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* released = _impl_.stocktype_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stocktype_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_stocktype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.stocktype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stocktype_.IsDefault()) {
    _impl_.stocktype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.stockType)
}

// optional string minSize = 24;
inline bool ContractDetails::has_minsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void ContractDetails::clear_minsize() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minsize_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const std::string& ContractDetails::minsize() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.minSize)
  return _internal_minsize();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_minsize(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.minsize_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.minSize)
}
inline std::string* ContractDetails::mutable_minsize() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_minsize();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.minSize)
  return _s;
}
inline const std::string& ContractDetails::_internal_minsize() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.minsize_.Get();
}
inline void ContractDetails::_internal_set_minsize(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.minsize_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_minsize() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00040000u;
  return _impl_.minsize_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_minsize() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.minSize)
  if ((_impl_._has_bits_[0] & 0x00040000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00040000u;
  auto* released = _impl_.minsize_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.minsize_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_minsize(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.minsize_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.minsize_.IsDefault()) {
    _impl_.minsize_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.minSize)
}

// optional string sizeIncrement = 25;
inline bool ContractDetails::has_sizeincrement() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void ContractDetails::clear_sizeincrement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sizeincrement_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const std::string& ContractDetails::sizeincrement() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.sizeIncrement)
  return _internal_sizeincrement();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_sizeincrement(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.sizeincrement_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.sizeIncrement)
}
inline std::string* ContractDetails::mutable_sizeincrement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sizeincrement();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.sizeIncrement)
  return _s;
}
inline const std::string& ContractDetails::_internal_sizeincrement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sizeincrement_.Get();
}
inline void ContractDetails::_internal_set_sizeincrement(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.sizeincrement_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_sizeincrement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00080000u;
  return _impl_.sizeincrement_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_sizeincrement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.sizeIncrement)
  if ((_impl_._has_bits_[0] & 0x00080000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00080000u;
  auto* released = _impl_.sizeincrement_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sizeincrement_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_sizeincrement(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.sizeincrement_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sizeincrement_.IsDefault()) {
    _impl_.sizeincrement_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.sizeIncrement)
}

// optional string suggestedSizeIncrement = 26;
inline bool ContractDetails::has_suggestedsizeincrement() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void ContractDetails::clear_suggestedsizeincrement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suggestedsizeincrement_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const std::string& ContractDetails::suggestedsizeincrement() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.suggestedSizeIncrement)
  return _internal_suggestedsizeincrement();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_suggestedsizeincrement(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.suggestedsizeincrement_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.suggestedSizeIncrement)
}
inline std::string* ContractDetails::mutable_suggestedsizeincrement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_suggestedsizeincrement();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.suggestedSizeIncrement)
  return _s;
}
inline const std::string& ContractDetails::_internal_suggestedsizeincrement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suggestedsizeincrement_.Get();
}
inline void ContractDetails::_internal_set_suggestedsizeincrement(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.suggestedsizeincrement_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_suggestedsizeincrement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00100000u;
  return _impl_.suggestedsizeincrement_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_suggestedsizeincrement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.suggestedSizeIncrement)
  if ((_impl_._has_bits_[0] & 0x00100000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00100000u;
  auto* released = _impl_.suggestedsizeincrement_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.suggestedsizeincrement_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_suggestedsizeincrement(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.suggestedsizeincrement_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.suggestedsizeincrement_.IsDefault()) {
    _impl_.suggestedsizeincrement_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.suggestedSizeIncrement)
}

// optional string fundName = 27;
inline bool ContractDetails::has_fundname() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const std::string& ContractDetails::fundname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundName)
  return _internal_fundname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.fundname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundName)
}
inline std::string* ContractDetails::mutable_fundname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundname();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundName)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundname_.Get();
}
inline void ContractDetails::_internal_set_fundname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.fundname_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00200000u;
  return _impl_.fundname_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundName)
  if ((_impl_._has_bits_[0] & 0x00200000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00200000u;
  auto* released = _impl_.fundname_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundname_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.fundname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundname_.IsDefault()) {
    _impl_.fundname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundName)
}

// optional string fundFamily = 28;
inline bool ContractDetails::has_fundfamily() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundfamily() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundfamily_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const std::string& ContractDetails::fundfamily() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundFamily)
  return _internal_fundfamily();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundfamily(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.fundfamily_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundFamily)
}
inline std::string* ContractDetails::mutable_fundfamily() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundfamily();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundFamily)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundfamily() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundfamily_.Get();
}
inline void ContractDetails::_internal_set_fundfamily(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.fundfamily_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundfamily() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00400000u;
  return _impl_.fundfamily_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundfamily() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundFamily)
  if ((_impl_._has_bits_[0] & 0x00400000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00400000u;
  auto* released = _impl_.fundfamily_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundfamily_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundfamily(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.fundfamily_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundfamily_.IsDefault()) {
    _impl_.fundfamily_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundFamily)
}

// optional string fundType = 29;
inline bool ContractDetails::has_fundtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundtype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const std::string& ContractDetails::fundtype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundType)
  return _internal_fundtype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundtype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.fundtype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundType)
}
inline std::string* ContractDetails::mutable_fundtype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundtype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundType)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundtype_.Get();
}
inline void ContractDetails::_internal_set_fundtype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.fundtype_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00800000u;
  return _impl_.fundtype_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundType)
  if ((_impl_._has_bits_[0] & 0x00800000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00800000u;
  auto* released = _impl_.fundtype_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundtype_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundtype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.fundtype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundtype_.IsDefault()) {
    _impl_.fundtype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundType)
}

// optional string fundFrontLoad = 30;
inline bool ContractDetails::has_fundfrontload() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundfrontload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundfrontload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const std::string& ContractDetails::fundfrontload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundFrontLoad)
  return _internal_fundfrontload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundfrontload(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.fundfrontload_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundFrontLoad)
}
inline std::string* ContractDetails::mutable_fundfrontload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundfrontload();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundFrontLoad)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundfrontload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundfrontload_.Get();
}
inline void ContractDetails::_internal_set_fundfrontload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.fundfrontload_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundfrontload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x01000000u;
  return _impl_.fundfrontload_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundfrontload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundFrontLoad)
  if ((_impl_._has_bits_[0] & 0x01000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x01000000u;
  auto* released = _impl_.fundfrontload_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundfrontload_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundfrontload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.fundfrontload_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundfrontload_.IsDefault()) {
    _impl_.fundfrontload_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundFrontLoad)
}

// optional string fundBackLoad = 31;
inline bool ContractDetails::has_fundbackload() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundbackload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundbackload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const std::string& ContractDetails::fundbackload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBackLoad)
  return _internal_fundbackload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundbackload(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.fundbackload_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBackLoad)
}
inline std::string* ContractDetails::mutable_fundbackload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundbackload();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBackLoad)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundbackload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundbackload_.Get();
}
inline void ContractDetails::_internal_set_fundbackload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.fundbackload_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundbackload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x02000000u;
  return _impl_.fundbackload_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundbackload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBackLoad)
  if ((_impl_._has_bits_[0] & 0x02000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x02000000u;
  auto* released = _impl_.fundbackload_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundbackload_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundbackload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.fundbackload_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundbackload_.IsDefault()) {
    _impl_.fundbackload_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBackLoad)
}

// optional string fundBackLoadTimeInterval = 32;
inline bool ContractDetails::has_fundbackloadtimeinterval() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundbackloadtimeinterval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundbackloadtimeinterval_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const std::string& ContractDetails::fundbackloadtimeinterval() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBackLoadTimeInterval)
  return _internal_fundbackloadtimeinterval();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundbackloadtimeinterval(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.fundbackloadtimeinterval_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBackLoadTimeInterval)
}
inline std::string* ContractDetails::mutable_fundbackloadtimeinterval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundbackloadtimeinterval();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBackLoadTimeInterval)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundbackloadtimeinterval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundbackloadtimeinterval_.Get();
}
inline void ContractDetails::_internal_set_fundbackloadtimeinterval(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.fundbackloadtimeinterval_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundbackloadtimeinterval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x04000000u;
  return _impl_.fundbackloadtimeinterval_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundbackloadtimeinterval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBackLoadTimeInterval)
  if ((_impl_._has_bits_[0] & 0x04000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x04000000u;
  auto* released = _impl_.fundbackloadtimeinterval_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundbackloadtimeinterval_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundbackloadtimeinterval(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.fundbackloadtimeinterval_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundbackloadtimeinterval_.IsDefault()) {
    _impl_.fundbackloadtimeinterval_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBackLoadTimeInterval)
}

// optional string fundManagementFee = 33;
inline bool ContractDetails::has_fundmanagementfee() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundmanagementfee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundmanagementfee_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const std::string& ContractDetails::fundmanagementfee() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundManagementFee)
  return _internal_fundmanagementfee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundmanagementfee(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.fundmanagementfee_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundManagementFee)
}
inline std::string* ContractDetails::mutable_fundmanagementfee() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundmanagementfee();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundManagementFee)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundmanagementfee() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundmanagementfee_.Get();
}
inline void ContractDetails::_internal_set_fundmanagementfee(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.fundmanagementfee_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundmanagementfee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x08000000u;
  return _impl_.fundmanagementfee_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundmanagementfee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundManagementFee)
  if ((_impl_._has_bits_[0] & 0x08000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x08000000u;
  auto* released = _impl_.fundmanagementfee_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundmanagementfee_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundmanagementfee(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.fundmanagementfee_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundmanagementfee_.IsDefault()) {
    _impl_.fundmanagementfee_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundManagementFee)
}

// optional bool fundClosed = 34;
inline bool ContractDetails::has_fundclosed() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundclosed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundclosed_ = false;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline bool ContractDetails::fundclosed() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundClosed)
  return _internal_fundclosed();
}
inline void ContractDetails::set_fundclosed(bool value) {
  _internal_set_fundclosed(value);
  _impl_._has_bits_[1] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundClosed)
}
inline bool ContractDetails::_internal_fundclosed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundclosed_;
}
inline void ContractDetails::_internal_set_fundclosed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundclosed_ = value;
}

// optional bool fundClosedForNewInvestors = 35;
inline bool ContractDetails::has_fundclosedfornewinvestors() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundclosedfornewinvestors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundclosedfornewinvestors_ = false;
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline bool ContractDetails::fundclosedfornewinvestors() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundClosedForNewInvestors)
  return _internal_fundclosedfornewinvestors();
}
inline void ContractDetails::set_fundclosedfornewinvestors(bool value) {
  _internal_set_fundclosedfornewinvestors(value);
  _impl_._has_bits_[1] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundClosedForNewInvestors)
}
inline bool ContractDetails::_internal_fundclosedfornewinvestors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundclosedfornewinvestors_;
}
inline void ContractDetails::_internal_set_fundclosedfornewinvestors(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundclosedfornewinvestors_ = value;
}

// optional bool fundClosedForNewMoney = 36;
inline bool ContractDetails::has_fundclosedfornewmoney() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundclosedfornewmoney() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundclosedfornewmoney_ = false;
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline bool ContractDetails::fundclosedfornewmoney() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundClosedForNewMoney)
  return _internal_fundclosedfornewmoney();
}
inline void ContractDetails::set_fundclosedfornewmoney(bool value) {
  _internal_set_fundclosedfornewmoney(value);
  _impl_._has_bits_[1] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundClosedForNewMoney)
}
inline bool ContractDetails::_internal_fundclosedfornewmoney() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundclosedfornewmoney_;
}
inline void ContractDetails::_internal_set_fundclosedfornewmoney(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundclosedfornewmoney_ = value;
}

// optional string fundNotifyAmount = 37;
inline bool ContractDetails::has_fundnotifyamount() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundnotifyamount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundnotifyamount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const std::string& ContractDetails::fundnotifyamount() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundNotifyAmount)
  return _internal_fundnotifyamount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundnotifyamount(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.fundnotifyamount_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundNotifyAmount)
}
inline std::string* ContractDetails::mutable_fundnotifyamount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundnotifyamount();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundNotifyAmount)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundnotifyamount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundnotifyamount_.Get();
}
inline void ContractDetails::_internal_set_fundnotifyamount(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.fundnotifyamount_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundnotifyamount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x10000000u;
  return _impl_.fundnotifyamount_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundnotifyamount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundNotifyAmount)
  if ((_impl_._has_bits_[0] & 0x10000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x10000000u;
  auto* released = _impl_.fundnotifyamount_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundnotifyamount_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundnotifyamount(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.fundnotifyamount_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundnotifyamount_.IsDefault()) {
    _impl_.fundnotifyamount_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundNotifyAmount)
}

// optional string fundMinimumInitialPurchase = 38;
inline bool ContractDetails::has_fundminimuminitialpurchase() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundminimuminitialpurchase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundminimuminitialpurchase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const std::string& ContractDetails::fundminimuminitialpurchase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundMinimumInitialPurchase)
  return _internal_fundminimuminitialpurchase();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundminimuminitialpurchase(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.fundminimuminitialpurchase_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundMinimumInitialPurchase)
}
inline std::string* ContractDetails::mutable_fundminimuminitialpurchase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundminimuminitialpurchase();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundMinimumInitialPurchase)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundminimuminitialpurchase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundminimuminitialpurchase_.Get();
}
inline void ContractDetails::_internal_set_fundminimuminitialpurchase(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.fundminimuminitialpurchase_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundminimuminitialpurchase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x20000000u;
  return _impl_.fundminimuminitialpurchase_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundminimuminitialpurchase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundMinimumInitialPurchase)
  if ((_impl_._has_bits_[0] & 0x20000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x20000000u;
  auto* released = _impl_.fundminimuminitialpurchase_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundminimuminitialpurchase_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundminimuminitialpurchase(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.fundminimuminitialpurchase_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundminimuminitialpurchase_.IsDefault()) {
    _impl_.fundminimuminitialpurchase_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundMinimumInitialPurchase)
}

// optional string fundMinimumSubsequentPurchase = 39;
inline bool ContractDetails::has_fundminimumsubsequentpurchase() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundminimumsubsequentpurchase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundminimumsubsequentpurchase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const std::string& ContractDetails::fundminimumsubsequentpurchase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
  return _internal_fundminimumsubsequentpurchase();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundminimumsubsequentpurchase(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.fundminimumsubsequentpurchase_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
}
inline std::string* ContractDetails::mutable_fundminimumsubsequentpurchase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundminimumsubsequentpurchase();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundminimumsubsequentpurchase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundminimumsubsequentpurchase_.Get();
}
inline void ContractDetails::_internal_set_fundminimumsubsequentpurchase(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.fundminimumsubsequentpurchase_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundminimumsubsequentpurchase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x40000000u;
  return _impl_.fundminimumsubsequentpurchase_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundminimumsubsequentpurchase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
  if ((_impl_._has_bits_[0] & 0x40000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x40000000u;
  auto* released = _impl_.fundminimumsubsequentpurchase_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundminimumsubsequentpurchase_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundminimumsubsequentpurchase(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.fundminimumsubsequentpurchase_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundminimumsubsequentpurchase_.IsDefault()) {
    _impl_.fundminimumsubsequentpurchase_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
}

// optional string fundBlueSkyStates = 40;
inline bool ContractDetails::has_fundblueskystates() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void ContractDetails::clear_fundblueskystates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundblueskystates_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const std::string& ContractDetails::fundblueskystates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBlueSkyStates)
  return _internal_fundblueskystates();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundblueskystates(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.fundblueskystates_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBlueSkyStates)
}
inline std::string* ContractDetails::mutable_fundblueskystates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundblueskystates();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBlueSkyStates)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundblueskystates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundblueskystates_.Get();
}
inline void ContractDetails::_internal_set_fundblueskystates(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.fundblueskystates_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundblueskystates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x80000000u;
  return _impl_.fundblueskystates_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundblueskystates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBlueSkyStates)
  if ((_impl_._has_bits_[0] & 0x80000000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x80000000u;
  auto* released = _impl_.fundblueskystates_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundblueskystates_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundblueskystates(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.fundblueskystates_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundblueskystates_.IsDefault()) {
    _impl_.fundblueskystates_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBlueSkyStates)
}

// optional string fundBlueSkyTerritories = 41;
inline bool ContractDetails::has_fundblueskyterritories() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline void ContractDetails::clear_fundblueskyterritories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundblueskyterritories_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const std::string& ContractDetails::fundblueskyterritories() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBlueSkyTerritories)
  return _internal_fundblueskyterritories();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundblueskyterritories(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.fundblueskyterritories_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBlueSkyTerritories)
}
inline std::string* ContractDetails::mutable_fundblueskyterritories() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundblueskyterritories();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBlueSkyTerritories)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundblueskyterritories() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundblueskyterritories_.Get();
}
inline void ContractDetails::_internal_set_fundblueskyterritories(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.fundblueskyterritories_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundblueskyterritories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000001u;
  return _impl_.fundblueskyterritories_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundblueskyterritories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBlueSkyTerritories)
  if ((_impl_._has_bits_[1] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000001u;
  auto* released = _impl_.fundblueskyterritories_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundblueskyterritories_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundblueskyterritories(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.fundblueskyterritories_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundblueskyterritories_.IsDefault()) {
    _impl_.fundblueskyterritories_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBlueSkyTerritories)
}

// optional string fundDistributionPolicyIndicator = 42;
inline bool ContractDetails::has_funddistributionpolicyindicator() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline void ContractDetails::clear_funddistributionpolicyindicator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.funddistributionpolicyindicator_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const std::string& ContractDetails::funddistributionpolicyindicator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundDistributionPolicyIndicator)
  return _internal_funddistributionpolicyindicator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_funddistributionpolicyindicator(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.funddistributionpolicyindicator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundDistributionPolicyIndicator)
}
inline std::string* ContractDetails::mutable_funddistributionpolicyindicator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_funddistributionpolicyindicator();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundDistributionPolicyIndicator)
  return _s;
}
inline const std::string& ContractDetails::_internal_funddistributionpolicyindicator() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.funddistributionpolicyindicator_.Get();
}
inline void ContractDetails::_internal_set_funddistributionpolicyindicator(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.funddistributionpolicyindicator_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_funddistributionpolicyindicator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000002u;
  return _impl_.funddistributionpolicyindicator_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_funddistributionpolicyindicator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundDistributionPolicyIndicator)
  if ((_impl_._has_bits_[1] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000002u;
  auto* released = _impl_.funddistributionpolicyindicator_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.funddistributionpolicyindicator_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_funddistributionpolicyindicator(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.funddistributionpolicyindicator_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.funddistributionpolicyindicator_.IsDefault()) {
    _impl_.funddistributionpolicyindicator_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundDistributionPolicyIndicator)
}

// optional string fundAssetType = 43;
inline bool ContractDetails::has_fundassettype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline void ContractDetails::clear_fundassettype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fundassettype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const std::string& ContractDetails::fundassettype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundAssetType)
  return _internal_fundassettype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_fundassettype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.fundassettype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundAssetType)
}
inline std::string* ContractDetails::mutable_fundassettype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fundassettype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundAssetType)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundassettype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fundassettype_.Get();
}
inline void ContractDetails::_internal_set_fundassettype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.fundassettype_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_fundassettype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000004u;
  return _impl_.fundassettype_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_fundassettype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundAssetType)
  if ((_impl_._has_bits_[1] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000004u;
  auto* released = _impl_.fundassettype_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fundassettype_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_fundassettype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.fundassettype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fundassettype_.IsDefault()) {
    _impl_.fundassettype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundAssetType)
}

// optional string cusip = 44;
inline bool ContractDetails::has_cusip() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline void ContractDetails::clear_cusip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cusip_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const std::string& ContractDetails::cusip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.cusip)
  return _internal_cusip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_cusip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.cusip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.cusip)
}
inline std::string* ContractDetails::mutable_cusip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cusip();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.cusip)
  return _s;
}
inline const std::string& ContractDetails::_internal_cusip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cusip_.Get();
}
inline void ContractDetails::_internal_set_cusip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.cusip_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_cusip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000008u;
  return _impl_.cusip_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_cusip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.cusip)
  if ((_impl_._has_bits_[1] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000008u;
  auto* released = _impl_.cusip_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.cusip_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_cusip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.cusip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cusip_.IsDefault()) {
    _impl_.cusip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.cusip)
}

// optional string issueDate = 45;
inline bool ContractDetails::has_issuedate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline void ContractDetails::clear_issuedate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuedate_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline const std::string& ContractDetails::issuedate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.issueDate)
  return _internal_issuedate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_issuedate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.issuedate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.issueDate)
}
inline std::string* ContractDetails::mutable_issuedate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_issuedate();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.issueDate)
  return _s;
}
inline const std::string& ContractDetails::_internal_issuedate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.issuedate_.Get();
}
inline void ContractDetails::_internal_set_issuedate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.issuedate_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_issuedate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000010u;
  return _impl_.issuedate_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_issuedate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.issueDate)
  if ((_impl_._has_bits_[1] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000010u;
  auto* released = _impl_.issuedate_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.issuedate_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_issuedate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  _impl_.issuedate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.issuedate_.IsDefault()) {
    _impl_.issuedate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.issueDate)
}

// optional string ratings = 46;
inline bool ContractDetails::has_ratings() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline void ContractDetails::clear_ratings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ratings_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline const std::string& ContractDetails::ratings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.ratings)
  return _internal_ratings();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_ratings(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.ratings_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.ratings)
}
inline std::string* ContractDetails::mutable_ratings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ratings();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.ratings)
  return _s;
}
inline const std::string& ContractDetails::_internal_ratings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ratings_.Get();
}
inline void ContractDetails::_internal_set_ratings(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.ratings_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_ratings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000020u;
  return _impl_.ratings_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_ratings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.ratings)
  if ((_impl_._has_bits_[1] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000020u;
  auto* released = _impl_.ratings_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ratings_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_ratings(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  _impl_.ratings_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ratings_.IsDefault()) {
    _impl_.ratings_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.ratings)
}

// optional string bondType = 47;
inline bool ContractDetails::has_bondtype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline void ContractDetails::clear_bondtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bondtype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline const std::string& ContractDetails::bondtype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.bondType)
  return _internal_bondtype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_bondtype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.bondtype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.bondType)
}
inline std::string* ContractDetails::mutable_bondtype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bondtype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.bondType)
  return _s;
}
inline const std::string& ContractDetails::_internal_bondtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bondtype_.Get();
}
inline void ContractDetails::_internal_set_bondtype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.bondtype_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_bondtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000040u;
  return _impl_.bondtype_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_bondtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.bondType)
  if ((_impl_._has_bits_[1] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000040u;
  auto* released = _impl_.bondtype_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.bondtype_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_bondtype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  _impl_.bondtype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bondtype_.IsDefault()) {
    _impl_.bondtype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.bondType)
}

// optional double coupon = 48;
inline bool ContractDetails::has_coupon() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline void ContractDetails::clear_coupon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coupon_ = 0;
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline double ContractDetails::coupon() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.coupon)
  return _internal_coupon();
}
inline void ContractDetails::set_coupon(double value) {
  _internal_set_coupon(value);
  _impl_._has_bits_[1] |= 0x00100000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.coupon)
}
inline double ContractDetails::_internal_coupon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coupon_;
}
inline void ContractDetails::_internal_set_coupon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coupon_ = value;
}

// optional string couponType = 49;
inline bool ContractDetails::has_coupontype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline void ContractDetails::clear_coupontype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coupontype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline const std::string& ContractDetails::coupontype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.couponType)
  return _internal_coupontype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_coupontype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.coupontype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.couponType)
}
inline std::string* ContractDetails::mutable_coupontype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_coupontype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.couponType)
  return _s;
}
inline const std::string& ContractDetails::_internal_coupontype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coupontype_.Get();
}
inline void ContractDetails::_internal_set_coupontype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.coupontype_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_coupontype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000080u;
  return _impl_.coupontype_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_coupontype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.couponType)
  if ((_impl_._has_bits_[1] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000080u;
  auto* released = _impl_.coupontype_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.coupontype_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_coupontype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }
  _impl_.coupontype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.coupontype_.IsDefault()) {
    _impl_.coupontype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.couponType)
}

// optional bool convertible = 50;
inline bool ContractDetails::has_convertible() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline void ContractDetails::clear_convertible() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.convertible_ = false;
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline bool ContractDetails::convertible() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.convertible)
  return _internal_convertible();
}
inline void ContractDetails::set_convertible(bool value) {
  _internal_set_convertible(value);
  _impl_._has_bits_[1] |= 0x00080000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.convertible)
}
inline bool ContractDetails::_internal_convertible() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.convertible_;
}
inline void ContractDetails::_internal_set_convertible(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.convertible_ = value;
}

// optional bool callable = 51;
inline bool ContractDetails::has_callable() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline void ContractDetails::clear_callable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.callable_ = false;
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline bool ContractDetails::callable() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.callable)
  return _internal_callable();
}
inline void ContractDetails::set_callable(bool value) {
  _internal_set_callable(value);
  _impl_._has_bits_[1] |= 0x00200000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.callable)
}
inline bool ContractDetails::_internal_callable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.callable_;
}
inline void ContractDetails::_internal_set_callable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.callable_ = value;
}

// optional bool puttable = 52;
inline bool ContractDetails::has_puttable() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline void ContractDetails::clear_puttable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.puttable_ = false;
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline bool ContractDetails::puttable() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.puttable)
  return _internal_puttable();
}
inline void ContractDetails::set_puttable(bool value) {
  _internal_set_puttable(value);
  _impl_._has_bits_[1] |= 0x00400000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.puttable)
}
inline bool ContractDetails::_internal_puttable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.puttable_;
}
inline void ContractDetails::_internal_set_puttable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.puttable_ = value;
}

// optional string descAppend = 53;
inline bool ContractDetails::has_descappend() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline void ContractDetails::clear_descappend() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.descappend_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline const std::string& ContractDetails::descappend() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.descAppend)
  return _internal_descappend();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_descappend(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.descappend_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.descAppend)
}
inline std::string* ContractDetails::mutable_descappend() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_descappend();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.descAppend)
  return _s;
}
inline const std::string& ContractDetails::_internal_descappend() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.descappend_.Get();
}
inline void ContractDetails::_internal_set_descappend(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.descappend_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_descappend() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000100u;
  return _impl_.descappend_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_descappend() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.descAppend)
  if ((_impl_._has_bits_[1] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000100u;
  auto* released = _impl_.descappend_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.descappend_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_descappend(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }
  _impl_.descappend_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.descappend_.IsDefault()) {
    _impl_.descappend_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.descAppend)
}

// optional string nextOptionDate = 54;
inline bool ContractDetails::has_nextoptiondate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline void ContractDetails::clear_nextoptiondate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nextoptiondate_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline const std::string& ContractDetails::nextoptiondate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.nextOptionDate)
  return _internal_nextoptiondate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_nextoptiondate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.nextoptiondate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.nextOptionDate)
}
inline std::string* ContractDetails::mutable_nextoptiondate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nextoptiondate();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.nextOptionDate)
  return _s;
}
inline const std::string& ContractDetails::_internal_nextoptiondate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nextoptiondate_.Get();
}
inline void ContractDetails::_internal_set_nextoptiondate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.nextoptiondate_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_nextoptiondate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000200u;
  return _impl_.nextoptiondate_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_nextoptiondate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.nextOptionDate)
  if ((_impl_._has_bits_[1] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000200u;
  auto* released = _impl_.nextoptiondate_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.nextoptiondate_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_nextoptiondate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }
  _impl_.nextoptiondate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.nextoptiondate_.IsDefault()) {
    _impl_.nextoptiondate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.nextOptionDate)
}

// optional string nextOptionType = 55;
inline bool ContractDetails::has_nextoptiontype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline void ContractDetails::clear_nextoptiontype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nextoptiontype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline const std::string& ContractDetails::nextoptiontype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.nextOptionType)
  return _internal_nextoptiontype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_nextoptiontype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.nextoptiontype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.nextOptionType)
}
inline std::string* ContractDetails::mutable_nextoptiontype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nextoptiontype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.nextOptionType)
  return _s;
}
inline const std::string& ContractDetails::_internal_nextoptiontype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nextoptiontype_.Get();
}
inline void ContractDetails::_internal_set_nextoptiontype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.nextoptiontype_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_nextoptiontype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000400u;
  return _impl_.nextoptiontype_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_nextoptiontype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.nextOptionType)
  if ((_impl_._has_bits_[1] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000400u;
  auto* released = _impl_.nextoptiontype_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.nextoptiontype_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_nextoptiontype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }
  _impl_.nextoptiontype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.nextoptiontype_.IsDefault()) {
    _impl_.nextoptiontype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.nextOptionType)
}

// optional bool nextOptionPartial = 56;
inline bool ContractDetails::has_nextoptionpartial() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline void ContractDetails::clear_nextoptionpartial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nextoptionpartial_ = false;
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline bool ContractDetails::nextoptionpartial() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.nextOptionPartial)
  return _internal_nextoptionpartial();
}
inline void ContractDetails::set_nextoptionpartial(bool value) {
  _internal_set_nextoptionpartial(value);
  _impl_._has_bits_[1] |= 0x00800000u;
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.nextOptionPartial)
}
inline bool ContractDetails::_internal_nextoptionpartial() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nextoptionpartial_;
}
inline void ContractDetails::_internal_set_nextoptionpartial(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nextoptionpartial_ = value;
}

// optional string bondNotes = 57;
inline bool ContractDetails::has_bondnotes() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline void ContractDetails::clear_bondnotes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bondnotes_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline const std::string& ContractDetails::bondnotes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.bondNotes)
  return _internal_bondnotes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractDetails::set_bondnotes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.bondnotes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.bondNotes)
}
inline std::string* ContractDetails::mutable_bondnotes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bondnotes();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.bondNotes)
  return _s;
}
inline const std::string& ContractDetails::_internal_bondnotes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bondnotes_.Get();
}
inline void ContractDetails::_internal_set_bondnotes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.bondnotes_.Set(value, GetArena());
}
inline std::string* ContractDetails::_internal_mutable_bondnotes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[1] |= 0x00000800u;
  return _impl_.bondnotes_.Mutable( GetArena());
}
inline std::string* ContractDetails::release_bondnotes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.bondNotes)
  if ((_impl_._has_bits_[1] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000800u;
  auto* released = _impl_.bondnotes_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.bondnotes_.Set("", GetArena());
  }
  return released;
}
inline void ContractDetails::set_allocated_bondnotes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }
  _impl_.bondnotes_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bondnotes_.IsDefault()) {
    _impl_.bondnotes_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.bondNotes)
}

// repeated .protobuf.IneligibilityReason ineligibilityReasonList = 58;
inline int ContractDetails::_internal_ineligibilityreasonlist_size() const {
  return _internal_ineligibilityreasonlist().size();
}
inline int ContractDetails::ineligibilityreasonlist_size() const {
  return _internal_ineligibilityreasonlist_size();
}
inline ::protobuf::IneligibilityReason* ContractDetails::mutable_ineligibilityreasonlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.ineligibilityReasonList)
  return _internal_mutable_ineligibilityreasonlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>* ContractDetails::mutable_ineligibilityreasonlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protobuf.ContractDetails.ineligibilityReasonList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ineligibilityreasonlist();
}
inline const ::protobuf::IneligibilityReason& ContractDetails::ineligibilityreasonlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.ineligibilityReasonList)
  return _internal_ineligibilityreasonlist().Get(index);
}
inline ::protobuf::IneligibilityReason* ContractDetails::add_ineligibilityreasonlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::protobuf::IneligibilityReason* _add = _internal_mutable_ineligibilityreasonlist()->Add();
  // @@protoc_insertion_point(field_add:protobuf.ContractDetails.ineligibilityReasonList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>& ContractDetails::ineligibilityreasonlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protobuf.ContractDetails.ineligibilityReasonList)
  return _internal_ineligibilityreasonlist();
}
inline const ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>&
ContractDetails::_internal_ineligibilityreasonlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ineligibilityreasonlist_;
}
inline ::google::protobuf::RepeatedPtrField<::protobuf::IneligibilityReason>*
ContractDetails::_internal_mutable_ineligibilityreasonlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ineligibilityreasonlist_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protobuf


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // ContractDetails_2eproto_2epb_2eh
